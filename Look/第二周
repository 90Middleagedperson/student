 扇区  512 字节
一块硬盘的“艺术”之旅
• 识别硬盘 => 分区规划 => 格式化 => 挂载使用
   毛坯楼层 => 打隔断 => 装修 => 入驻

 格式化:赋予空间存储数据的规则(文件系统)

一  识别硬盘,由系统自动完成
[root@server0 ~]# lsblk    #列出所有识别的硬盘设备 
NAME    SIZE  TYPE MOUNTPOINT
vda      10G  disk 
└─vda1  10G  part /
vdb      10G  disk 

[root@server0 ~]# ls /dev/vdb

二  分区的规划  

    MBR分区模式
          三种分区类型: 主分区   扩展分区   逻辑分区

          3个主分区, 一个扩展分区, N个逻辑分区

          可以存储数据的分区: 主分区  逻辑分区

          最多划分4主分区
          此模式支持最大空间  2.2T

划分分区   
[root@server0 ~]# fdisk  /dev/vdb
  n 创建新的分区----->回车----->回车---->回车----->在last结束时 +2G
  p 查看分区表
  n 创建新的分区----->回车----->回车---->回车----->在last结束时 +1G
  d 删除分区
  w 保存并退出

[root@server0 ~]# lsblk      #查看划分的分区信息
[root@server0 ~]# ls /dev/vdb[1-2]

三 格式化分区,赋予文件系统
[root@server0 ~]# mkfs.ext4 /dev/vdb1  #格式化成ext4
[root@server0 ~]# blkid /dev/vdb1    #查看文件系统类型
 
[root@server0 ~]# mkfs.xfs /dev/vdb2  #格式化成xfs
[root@server0 ~]# blkid /dev/vdb2     #查看文件系统类型

四  挂载使用
[root@server0 ~]# mkdir /part1
[root@server0 ~]# mount /dev/vdb1 /part1
[root@server0 ~]# df  -h   #查看正在挂载分区的使用情况
[root@server0 ~]# mkdir /part2
[root@server0 ~]# mount /dev/vdb2 /part2
[root@server0 ~]# df  -h   #查看正在挂载分区的使用情况

五  开机自动挂载
• 配置文件 /etc/fstab 的记录格式
 – 设备路径      挂载点       类型      参数         备份标记   检测顺序
 
[root@server0 ~]# vim  /etc/fstab
/dev/vdb1  /part1  ext4   defaults 0 0
/dev/vdb2  /part2  xfs   defaults 0 0

[root@server0 ~]# umount /dev/vdb1
[root@server0 ~]# umount /dev/vdb2
[root@server0 ~]# df -h
[root@server0 ~]# mount -a 
   检测/etc/fstab开机自动挂载配置文件,格式是否正确
   检测/etc/fstab中,书写完成,但当前没有挂载的设备,进行挂载  
[root@server0 ~]# df -h

六  综合分区
    3个主分区  一个扩展分区   N个逻辑分区
   最终有3个主分区，分别为2G、1G、1G
   创建扩展分区 --->  两个逻辑分区，分别为1G、1G
[root@server0 ~]# fdisk  /dev/vdb
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +1G
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车  将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+1G
   n 创建逻辑分区----->起始回车------>结束+1G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# partprobe   #刷新所有分区 
[root@server0 ~]# lsblk

  设备表示含义
   /dev/sda5: 
           SCSI接口的硬盘 第一块硬盘 的第5个分区
           SCSI接口的硬盘 第一块硬盘 的第1个逻辑分区

##############################################

总结:
1.识别硬盘   lsblk
2.进行分区   fdisk
3.刷新所有分区   partprobe
4.进行格式化    mkfs.ext4  mkfs.xfs  blkid(查看文件系统)
5.挂载使用  mount  ---> df -h (查看是否挂载成功)
6.书写配置文件/etc/fstab   ---> mount -a(测试)

#################################################
继续分区,关闭虚拟机server,添加一块新的硬盘
1.关闭虚拟机server,图形添加一块新的硬盘
[root@server0 ~]# poweroff 
Connection to 172.25.0.11 closed by remote host.
Connection to 172.25.0.11 closed.
[root@room9pc01 ~]# 
[root@room9pc01 ~]# ssh -X root@172.25.0.11
[root@server0 ~]# lsblk 

2.划分分区
 分区要求：划分3个主分区   1个扩展分区    2个逻辑分区
[root@server0 ~]# fdisk  /dev/vdc  
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +10G
         连续创建3个10G主分区
      ......
   n 创建扩展分区 
               ----->回车---->起始回车----->结束回车  将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# lsblk 

###############################################
LVM逻辑卷   

   作用: 
      1.可以整合分散的空间(分区或整个硬盘)
      2.空间可以扩大

     将众多的物理卷(PV)组建成卷组(VG),再从卷组中划分逻辑卷(LV)

      砖------>大房子------>打隔断------->装修------->入住


successfully 成功


一  创建逻辑卷
1.创建卷组
 命令格式: vgcreate 卷组名   设备路径------{。。挂载或者使用的分区不可创建卷组。。}
[root@server0 ~]# vgcreate  systemvg  /dev/vdc[1-2]
  Physical volume "/dev/vdc1" successfully created
  Physical volume "/dev/vdc2" successfully created
  Volume group "systemvg" successfully created
[root@server0 ~]# pvs #查看物理卷信息
[root@server0 ~]# vgs #查看卷组信息

2.创建逻辑卷
命令格式: lvcreate -L 逻辑卷的大小   -n 逻辑卷的名称  设备路径

  # lvcreate -L 16G -n mylv systemvg      
  # lvs   #查看逻辑卷信息

3.逻辑卷的使用
[root@server0 ~]# mkfs.ext4  /dev/systemvg/mylv 
[root@server0 ~]# blkid  /dev/systemvg/mylv
[root@server0 ~]# vim  /etc/fstab
/dev/systemvg/mylv  /lv  ext4  defaults 0 0

[root@server0 ~]# mkdir /lv
[root@server0 ~]# mount -a
[root@server0 ~]# df -h

###############################################
  逻辑卷的空间来源于卷组, 只能找基于它创建的卷组

二  逻辑卷的扩展:支持线上工作

1.卷组有足够的剩余空间       
[root@server0 ~]# lvs
[root@server0 ~]# vgs
 A:直接扩展逻辑卷的空间
[root@server0 ~]# lvextend -L 18G /dev/systemvg/mylv 
[root@server0 ~]# lvs
 B:文件系统的扩大
   resize2fs :刷新ext4文件系统
   xfs_growfs:刷新xfs文件系统
[root@server0 ~]# df -h
[root@server0 ~]# resize2fs /dev/systemvg/mylv 
[root@server0 ~]# df -h

2.卷组没有足够的剩余空间
   A:首先扩展卷组
[root@server0 ~]# vgs
[root@server0 ~]# lvs
[root@server0 ~]# vgextend systemvg /dev/vdc3
[root@server0 ~]# vgs
   B:直接扩展逻辑卷的空间
[root@server0 ~]# lvextend -L 25G /dev/systemvg/mylv 
[root@server0 ~]# lvs
   C:文件系统的扩大
[root@server0 ~]# df -h
[root@server0 ~]# resize2fs /dev/systemvg/mylv 
[root@server0 ~]# df -h

###############################################
了解:  逻辑卷也可以减小
      ext4文件系统支持减小
      xfs文件系统不支持减小

 卷组划分空间的单位:  PE  默认 4M

[root@server0 ~]# vgdisplay  #显示卷组详细信息

  PE Size         4.00 MiB  



    请创建一个大小为250M的逻辑卷redhat.
  # vgchange -s 1M  systemvg      #修改PE的大小
  # vgdisplay      #显示卷组详细信息

  # lvcreate -L 250M -n redhat   systemvg 
  # lvs

• 创建逻辑卷的时候指定PE个数
– lvcreate -l PE个数   -n 逻辑卷名 卷组名

# lvcreate -l 50 -n lvtest01   systemvg 
# lvs

• 创建卷组的时候设置PE大小
– vgcreate -s PE大小 卷组名 空闲分区...

# vgcreate -s 16MiB datastore /dev/vdb6

# vgchange -s  16MiB  卷组名   #卷组已存在可以修改PE大小






2. 基于刚建立的 2000MiB 分区构建新的 LVM 存储
– 新的逻辑卷命名为 database,大小为50个物理扩展单
元(Physical Extent),属于 datastore 卷组
– 在 datastore 卷组中的所有逻辑卷,其物理扩展单元
(Physical Extent)的大小为16MiB
– 使用 EXT3 文件系统对逻辑卷 database 格式化,此逻
辑卷应该在开机时自动挂载到 /mnt/database 目录


###############################################
逻辑卷删除
  创建:先创建物理卷,在创建卷组,最后创建逻辑卷

  删除:先删除逻辑卷,在删除卷组,最后删除物理卷

[root@server0 ~]# lvremove /dev/systemvg/mylv 
  Logical volume systemvg/mylv contains a filesystem in use.
[root@server0 ~]# umount /lv
[root@server0 ~]# lvremove /dev/systemvg/mylv 
Do you really want to remove active logical volume mylv? [y/n]: y
  Logical volume "mylv" successfully removed
[root@server0 ~]# 

删除所有的逻辑卷后,可以删除卷组
[root@server0 ~]# vgremove systemvg 
  Volume group "systemvg" successfully removed
[root@server0 ~]# vgs
  No volume groups found
[root@server0 ~]# 



[root@server0 ~]# pvremove /dev/vdc[1-3]
[root@server0 ~]# pvs



for循环

for循环处理
• 遍历/列表式循环
– 根据变量的不同取值,重复执行xx处理

	for 变量名   in  值列表
	do
	    重复执行的代码
	done

	for  献血车    in  队伍 
	do
                  抽血~
	done

[root@server0 ~]# vim /root/for01.sh
	#!/bin/bash
	for i  in  zhangsan lisi  wangwu 
	do
	 useradd $i &> /dev/null
	 echo $i创建成功
	done

[root@server0 ~]# vim /root/for02.sh
	#!/bin/bash
	for i  in  1 2 3 4 5
	do
	      echo 'I Love girl !!!'
	done

[root@server0 ~]#  

  造数机制: {起始值..结束值}
             {1..10}:  1到10 所有的数字         
             {20..38}:  20到38所有的数字
[root@server0 ~]# touch /opt/{1..20}.txt
[root@server0 ~]# ls /opt/

[root@server0 ~]# vim /root/for02.sh
 #!/bin/bash
 for i in {1..15}
 do
  echo 'I Love Dc !!!'  $i
 done
[root@server0 ~]# 

################################################

案例4:编写一个判断脚本
在 server0 上创建 /root/foo.sh 脚本
1)当运行/root/foo.sh redhat,输出为fedora
2)当运行/root/foo.sh fedora,输出为redhat
3)当没有任何参数或者参数不是 redhat 或者fedora时,
其错误输出产生以下信息: /root/foo.sh redhat|fedora

[root@server0 ~]# vim /root/foo.sh  
  #!/bin/bash
  if  [ $# -eq 0 ];then          #判断用户是否输入参数
   echo '/root/foo.sh redhat|fedora' >&2 #变成错误输出
   exit 1   #程序退出返回值为1
  elif  [ $1 == redhat ];then
   echo fedora
  elif  [ $1 == fedora ];then
   echo redhat
  else
   echo '/root/foo.sh redhat|fedora' >&2 #变成错误输出
   exit 2   #程序退出返回值为2
  fi
[root@server0 ~]# 


###########################################
案例5:编写一个批量添加用户脚本
在 server0 上创建 /root/batchusers 脚本
1)此脚本要求提供用户名列表文件作为参数
用户列表测试文件:
http://classroom/pub/materials/userlist
[root@server0 ~]# cat /root/userlist 
duanwu
zhongqiu
zhsan
lisi
dc
tc
dz
tz
harry
natasha
[root@server0 ~]# 

2)如果没有提供参数,此脚本应该给出提示 
Usage: /root/batchusers,退出并返回相应值
3)如果提供一个不存在的文件,此脚本应该给出提
示 Input file not found,退出并返回相应值
4)新用户的登录Shell为 /bin/false,无需设置密码


[root@server0 ~]# vim  /root/userlist
   zhangsan
   lisi
   dc
   tc
   dz
[root@server0 ~]# vim /root/batchusers  
#!/bin/bash
if  [  $#  -eq  0  ];then
 echo 'Usage: /root/batchusers' >&2
 exit 1
elif [   -f  $1 ];then
 for  i  in  `cat $1`
 do
   useradd -s /bin/false  $i  &> /dev/null
   echo $i 创建成功
 done
else
  echo 'Input file not found' >&2
  exit 2
fi
[root@server0 ~]# 

################################################
系统安全保护

SELinux概述
• Security-Enhanced Linux
– 美国NSA国家安全局主导开发,一套增强Linux系统安
全的强制访问控制体系

– 集成到Linux内核(2.6及以上)中运行
– RHEL7基于SELinux体系针对用户、进程、目录和文件
提供了预设的保护策略,以及管理工具


• SELinux的运行模式
– enforcing(强制)、permissive(宽松)
– disabled(彻底禁用)

 任何模式变成disabled都要经历重起系统

• 切换运行模式
– 临时切换:setenforce 1|0
– 固定配置:/etc/selinux/config 文件


两台虚拟机均设备状态为Permissive(宽松模式)
[root@server0 ~]# getenforce   #查看当前SELinux状态
Enforcing
[root@server0 ~]# setenforce 0 #设置当前SELinux状态
[root@server0 ~]# getenforce 
Permissive
[root@server0 ~]# vim /etc/selinux/config
SELINUX=permissive

#################################################
配置用户环境

• 影响指定用户的 bash 解释环境
– ~/.bashrc,每次开启 bash 终端时生效

• 影响所有用户的 bash 解释环境
– /etc/bashrc,每次开启 bash 终端时生效

[root@server0 ~]# vim /root/.bashrc 
alias hello='echo  hello'
[root@server0 ~]# vim /home/student/.bashrc
alias hi='echo  hi'
[root@server0 ~]# vim /etc/bashrc
alias haxi='echo  hahaxixi'

[root@server0 ~]# hello   #运行成功
[root@server0 ~]# hi      #运行失败
[root@server0 ~]# haxi    #运行成功
[root@server0 ~]# su - student
[student@server0 ~]$ hello #运行失败
[student@server0 ~]$ hi    #运行成功 
[student@server0 ~]$ haxi  #运行成功 
[student@server0 ~]$ exit

##############################################
防火墙

在虚拟机server:搭建Web服务       

   1.安装httpd(Apache)软件包(服务端软件)
  [root@server0 ~]# yum  -y  install   httpd  
 
   2.重起httpd服务
  [root@server0 ~]# systemctl restart httpd
  [root@server0 ~]# systemctl enable httpd

   3.书写一个页面文件
      默认存放网页文件的路径:/var/www/html
      默认网页文件的名字:index.html
  [root@server0 ~]# vim /var/www/html/index.html 
  <marquee><font color=red><h1>NSD1809 阳光明媚
     滚动           字体颜色为红色     最大字体
  [root@server0 ~]# 

   4.本机测试
  [root@server0 ~]# firefox 172.25.0.11

虚拟机server搭建FTP服务(实现文件的传输)

   1.安装vsftpd服务端软件
  [root@server0 ~]# yum -y install vsftpd
   2.重起vsftpd服务
  [root@server0 ~]# systemctl restart vsftpd
  [root@server0 ~]# systemctl enable vsftpd
    
    默认FTP共享数据的路径:/var/ftp

  [root@server0 ~]# firefox ftp://172.25.0.11

#################################################
防火墙的应用

    作用: 隔离  过滤

    硬件防火墙:一般保护的一个网络所有主机

    软件防火墙:一般保护本机

RHEL7的防火墙体系             
• 系统服务:firewalld
• 管理工具:firewall-cmd(命令)、firewall-config(图形)

    默认规则:  允许出站,过滤入站


################################################
预设安全区域
• 根据所在的网络场所区分,预设保护规则集
– public:仅允许访问本机的sshd dhcp  ping少数几个服务
– trusted:允许任何访问
– block:拒绝任何来访请求(明确拒绝)
– drop:丢弃任何来访的数据包(非明确拒绝,直接丢弃,节省资源)


  数据包: 源IP地址   目标IP地址   数据

 防火墙判断的机制: 匹配及停止
  1.查看客户端数据包中源IP地址,查看所有区域哪一个区域有该源IP地址策略,则进入该区域   

  2.进入默认区域(public)

##################################################
默认区域的修改
虚拟机server0:
# firewall-cmd --get-default-zone    #查看默认区域
# firewall-cmd --set-default-zone=block  #修改默认区域
# firewall-cmd --get-default-zone 
虚拟机desktop0:
# ping 172.25.0.11  #不能通信,但有回应

虚拟机server0:
# firewall-cmd --get-default-zone 
# firewall-cmd --set-default-zone=drop
# firewall-cmd --get-default-zone 
虚拟机desktop0:
# ping 172.25.0.11  #不能通信,没有回应

#################################################
在区域中添加允许的协议

  互联网常见的协议
           http:超文本传输协议80
           https:安全超文本传输协议443
           FTP:文件传输协议20 21
           DNS:域名解析协议53
           telnet:远程管理协议23
           tftp:简单文件传输协议69
           SMTP:邮件协议(用户发邮件)25
           pop3:邮件协议(用户收邮件)110
           snmp:网络管理协议161
	iscsi 3260
	mysql 3306
	php 9000
虚拟机server0:
# firewall-cmd --set-default-zone=public 
# firewall-cmd --zone=public --list-all  #查看区域规则
# firewall-cmd --zone=public --add-service=http
# firewall-cmd --zone=public --list-all 
虚拟机desktop0:
# firefox 172.25.0.11         #访问成功
# firefox ftp://172.25.0.11   #访问失败

虚拟机server0:
# firewall-cmd --zone=public  --add-service=ftp
# firewall-cmd --zone=public  --list-all 
虚拟机desktop0:
# firefox 172.25.0.11         #访问成功
# firefox ftp://172.25.0.11   #访问成功

###############################################
永久防火墙策略
– 永久(permanent):将规则写入相关配置文件
# firewall-cmd --reload   #重新加载防火墙所有配置文件规则
# firewall-cmd --zone=public  --list-all
# firewall-cmd --permanent --zone=public  --add-service=http

# firewall-cmd --zone=public   --list-all
# firewall-cmd --reload   #重新加载防火墙所有配置文件规则
# firewall-cmd --zone=public   --list-all

# firewall-cmd --permanent --zone=public  --add-service=ftp

# firewall-cmd --reload  #重新加载防火墙所有配置文件规则
# firewall-cmd --zone=public   --list-all

###########################################
临时删除
# firewall-cmd --zone=public  --remove-service=http

永久删除(删除配置文件中规则)
# firewall-cmd --permanent --zone=public   --remove-service=http

# firewall-cmd  --reload   
# firewall-cmd  --zone=public  --list-all 

############################################
在区域中添加源IP地址策略
虚拟机server0:将虚拟机desktop0的IP地址,加入到block区域中
# firewall-cmd --zone=block --add-source=172.25.0.10
# firewall-cmd --zone=block --list-all 

虚拟机desktop0:
# firefox 172.25.0.11         #访问失败
# firefox ftp://172.25.0.11   #访问失败

真机访问测试:
# firefox 172.25.0.11         #访问成功
# firefox ftp://172.25.0.11   #访问成功

##############################################






虚拟机server0:
1.搭建Yum仓库
[root@server0 ~]# rm -rf /etc/yum.repos.d/*
[root@server0 ~]# vim /etc/yum.repos.d/abc.repo

baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd/
2.安装httpd软件
[root@server0 ~]# yum -y install httpd

3.书写一个页面文件:
# echo '<h1>NSD1809 Web' > /var/www/html/index.html
# cat /var/www/html/index.html

4.重起服务验证
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enable httpd
[root@server0 ~]# firefox 172.25.0.11


#################################################
防火墙的应用

  互联网常见的协议 
         http:超文本传输协议         默认端口:80
         https:安全超文本传输协议  默认端口:443
         FTP:文件传输协议   默认端口:21
         DNS:域名解析协议    默认端口:53
         telnet:远程管理协议   默认端口:23
         tftp:简单文件传输协议   默认端口:69
         SMTP:邮件协议(用户发邮件)   默认端口:25
         pop3:邮件协议(用户收邮件)   默认端口:110
         snmp:网络管理协议    默认端口:161


  端口: 程序或服务或协议的编号   标识
  数据包:源IP地址  目标IP地址  数据  目标端口号



实现本机的端口映射(端口转发)
• 本地应用的端口重定向(端口1 --> 端口2)
  – 从客户机访问 端口1 的请求,自动映射到本机 端口2
  – 比如,访问以下两个地址可以看到相同的页面:
 http://172.25.0.11:5423/----->172.25.0.11:80

虚拟机server0:
# firewall-cmd --permanent  --zone=public --add-service=http

# firewall-cmd --reload 

# firewall-cmd --permanent --zone=public 
--add-forward-port=port=5423:proto=tcp:toport=80

# firewall-cmd --reload 

# firewall-cmd --zone=public --list-all

虚拟机desktop0: #firefox  172.25.0.11:5423

##################################################
Samba服务基础:实现跨平台的共享(Windows与Linux)
   
• Samba 软件项目
  – 用途:为客户机提供共享使用的文件夹
  – 协议:SMB(TCP 139)、CIFS(TCP 445)
  • 所需软件包:samba
  • 系统服务:smb

• Samba用户 —— 专用来访问共享文件夹的用户
– 采用独立设置的密码  
– 但需要提前建立同名的系统用户  
• 使用 pdbedit 管理工具
– 添加用户:pdbedit -a 用户名
– 查询用户:pdbedit -L [用户名]
– 删除用户:pdbedit -x 用户名

• 修改 /etc/samba/smb.conf
[自定共享名]
path = 文件夹绝对路径
; public = no|yes      //默认no
; browseable = yes|no //默认yes
; read only = yes|no   //默认yes
; write list = 用户1 .. .. //默认无
; valid users = 用户1 .. .. //默认任何用户
; hosts allow = 客户机地址 .. ..
; hosts deny = 客户机地址 .. ..

 一  环境配置               
虚拟机Server0:
# firewall-cmd --set-default-zone=trusted
 
虚拟机Desktop0:
# firewall-cmd --set-default-zone=trusted 

二 搭建基本的Samba服务
虚拟机Server0
1.安装samba软件包
[root@server0 ~]# yum -y install samba

2.创建Samba的共享帐号
 # useradd -s /sbin/nologin harry
 # useradd -s /sbin/nologin kenji
 # useradd -s /sbin/nologin chihiro
 # pdbedit -L          #查看所有Samba的共享帐号
 # pdbedit -a harry    #将harry添加为共享帐号
 # pdbedit -a kenji    #将kenji添加为共享帐号
 # pdbedit -a chihiro  #将chihiro添加为共享帐号
 # pdbedit -L          #查看所有Samba的共享帐号

3.修改配置文件/etc/samba/smb.conf
  1)创建目录
[root@server0 ~]# mkdir  /common
[root@server0 ~]# echo  123  >  /common/1.txt
[root@server0 ~]# ls  /common/

  2)此服务器必须是 STAFF 工作组的一个成员
     发布目录 /common,共享名为 common
[root@server0 ~]# vim  /etc/samba/smb.conf
  末行模式  输入 :set  nu  开启行号

    89   workgroup = STAFF

  命令模式  按 G(大写) 到全文最后
	321  [common]           #共享名
	322  path = /common     #共享实际路径

3.重起smb服务
[root@server0 ~]# systemctl restart smb
[root@server0 ~]# systemctl enable smb

4.SELinux的布尔值策略(功能的开关)
  – 需要加 -P 选项才能实现永久设置(需要内存的支持)

# getsebool -a | grep samba        #查看samba服务布尔值
# setsebool samba_export_all_ro on #修改samba服务布尔值
# getsebool -a | grep samba


客户端:虚拟机desktop0

1.安装客户端软件包samba-client
[root@desktop0 ~]# yum -y install samba-client

• 列出共享资源
– smbclient -L 服务器地址
• 连接到共享文件夹
– smbclient -U 用户名 //服务器地址/共享名

虚拟机desktop0:
# smbclient  -L   172.25.0.11
Enter root's password:       #直接敲回车
Anonymous login successful
Domain=[STAFF] OS=[Unix] Server=[Samba 4.1.1]

	Sharename       Type      Comment
	---------                      ----                 -------
	common          Disk     

# smbclient -U harry  //172.25.0.11/common
Enter harry's password:      #输入harry的密码
Domain=[STAFF] OS=[Unix] Server=[Samba 4.1.1]
smb: \> 



#################################################
客户端访问服务端:
  1.防火墙策略
  2.服务端的服务本身访问控制
  3.安全增强版 SELinux
  4.本地目录的权限

##############################################
总结:
搭建Samba服务:
  1.修改防火墙策略
  2.安装软件包samba
  3.创建Samba共享帐号   pdbedit
  4.创建共享目录,修改配置文件发布共享 
  5.重起smb服务
  6.修改SELinux功能的开关

客户端:
   1.修改防火墙策略
   2.安装软件包samba-clinet
   3.访问
################################################

客户端:更加科学方便的访问方式  
  mount挂载:本地目录作为Samba服务的访问点

1.安装cifs-utils软件包,支持cifs文件系统的软件包
[root@desktop0 /]# yum -y install cifs-utils

2.挂载访问
[root@desktop0 /]# mkdir /mnt/smb

# mount -o user=harry,pass=123  //172.25.0.11/common    /mnt/smb/

[root@desktop0 /]# df  -h   #查看正在挂载的所有设备

[root@desktop0 /]# ls /mnt/smb/
[root@desktop0 /]# cat /mnt/smb/1.txt 

3.开机自动挂载/etc/fstab
  _netdev:网络设备
                   指明本设备需要具备所有网络参数后,在进行挂载

[root@desktop0 /]# vim /etc/fstab 
//172.25.0.11/common  /mnt/smb   cifs defaults,user=harry,pass=123,_netdev   0  0

[root@desktop0 /]# umount  /mnt/smb/
[root@desktop0 /]# df -h
[root@desktop0 /]# mount -a  #检测开机自动挂载是否书写正确
[root@desktop0 /]# df -h

################################################
总结:
搭建Samba服务:
  1.修改防火墙策略
  2.安装软件包samba
  3.创建Samba共享帐号   pdbedit
  4.创建共享目录,修改配置文件发布共享 
  5.重起smb服务
  6.修改SELinux功能的开关

客户端:
   1.修改防火墙策略
   2.安装软件包cifs-utils
   3.利用mount挂载的方式
   4.实现开机自动挂载

###############################################
读写的Samba共享

服务端虚拟机server0:
1.创建共享目录
[root@server0 /]# mkdir /devops
[root@server0 /]# echo abc > /devops/a.txt
[root@server0 /]# ls /devops/

2.修改配置文件/etc/samba/smb.conf
 [devops]
 path = /devops
 write list = chihiro  #允许chihiro用户可以写入

3.重起smb服务
[root@server0 /]# systemctl  restart smb

4.修改SELinux布尔值
[root@server0 /]# getsebool -a | grep samba
[root@server0 /]# setsebool samba_export_all_rw on
[root@server0 /]# getsebool -a | grep samba

5.服务端本地目录权限
[root@server0 /]# setfacl -m u:chihiro:rwx /devops
[root@server0 /]# getfacl /devops

客户端:虚拟机desktop0 
1.完成开机自动挂载
[root@desktop0 /]# vim /etc/fstab 

//172.25.0.11/devops  /mnt/dev   cifs defaults,user=chihiro,pass=123,_netdev   0   0

[root@desktop0 /]# mkdir /mnt/dev
[root@desktop0 /]# mount -a
[root@desktop0 /]# df -h
##################################################
总结:读写Samba共享
搭建Samba服务:
  1.修改防火墙策略
  2.安装软件包samba
  3.创建Samba共享帐号   pdbedit
  4.创建共享目录,修改配置文件发布共享,添加可写用户
  5.重起smb服务
  6.修改SELinux功能的开关(rw读写功能)
  7.赋予本地目录(可写用户身份)读写执行的权限

客户端:
   1.修改防火墙策略
   2.安装软件包cifs-utils
   3.利用mount挂载的方式
   4.实现开机自动挂载
###############################################
配置NFS共享(完成Linux与Linux的之间的共享)
• Network File System,网络文件系统
– 用途:为客户机提供共享使用的文件夹
– 协议:NFS(TCP/UDP 2049)、RPC(TCP/UDP 111)
• 所需软件包:nfs-utils
• 系统服务:nfs-server

虚拟机Server0:只读NFS共享的实现
1.安装软件包
[root@server0 /]# yum -y install nfs-utils
[root@server0 /]# rpm -q nfs-utils
nfs-utils-1.3.0-0.el7.x86_64
[root@server0 /]# 

2.创建共享目录发布共享
[root@server0 /]# mkdir /public
[root@server0 /]# echo haha  > /public/abc.txt
[root@server0 /]# ls /public/

• 修改 /etc/exports
– 文件夹路径    客户机地址(权限) 客户机地址(权限) .. ..

[root@server0 /]# vim /etc/exports
/public    *(ro)

3.重起nfs-server服务
[root@server0 /]# systemctl restart nfs-server
[root@server0 /]# systemctl enable nfs-server


客户端:虚拟机Desktop0
  • 查看NFS资源
  – showmount -e [服务器地址]
 [root@desktop0 ~]# showmount -e 172.25.0.11

  • 挂载NFS共享目录
  – mount 服务器地址:目录路径   本地挂载点

[root@desktop0 /]# vim /etc/fstab 
172.25.0.11:/public /mnt/nfs nfs defaults,_netdev 0 0

[root@desktop0 /]# mkdir /mnt/nfs
[root@desktop0 /]# mount -a
[root@desktop0 /]# df -h
##############################################



搭建读写的Samba共享
	-发布共享/nsd,共享名为test
	-共享用户kenji对共享具备读写权限

虚拟机Server0:
1.安装软件samba          
2.创建用户kenji,将kenji用户添加为共享帐号,密码为123
3.创建用户harry,将harry用户添加为共享帐号,密码为321
4.修改配置文件/etc/samba/smb.conf
    [共享名]
  path = 共享实际路径
  write list = 可写用户
5.创建/nsd目录,在此目录创建文件1.txt
6.重起smb服务,设置smb服务为开机自起
7.防护墙默认区域为trusted
8.修改SELinux的布尔值,开启samba的rw读写功能
9.利用ACL为kenji用户,对/nsd目录有读写执行权限

客户端:虚拟机desktop0
 1.防护墙默认区域为trusted
 2.安装软件包cifs-utils
 3.将samba虚拟机Server0的共享, 
   实现开机自动挂载到 本机的/mnt/smb

#################################################
multiuser机制
 作用:客户端挂载时采用权限较小的用户挂载,当客户端有一个普通用户需要较大的权限,可以临时切换Samba共享帐号的身份

• SMB客户端的 multiuser 挂载技术
– 管理员只需要作一次挂载
– 客户端在访问挂载点时,若需要不同权限,可以临时
切换为新的共享用户(无需重新挂载)

• mount.cifs 的挂载参数
– multiuser,提供对客户端多个用户身份的区分支持
– sec=ntlmssp,提供NT局域网管理安全支持


$ cifscreds add -u kenji 172.25.0.11  //提交共享新身份
Password:                   

################################################
搭建读写的Samba共享
	-发布共享/public,共享名为haxi
	-共享用户chihiro对共享具备读写权限

虚拟机server:发布共享/public,共享名为haxi

虚拟机desktop:将共享,开机自动挂载到/mnt/samba

################################################
iSCSI网络磁盘(共享分区或整个磁盘)  默认端口:3260
• Internet SCSI,网际SCSI接口
– 一种基于C/S架构的虚拟磁盘技术
– 服务器提供磁盘空间,客户机连接并当成本地磁盘使用

• backstore,后端存储(大冰箱)  /dev/vdb1
– 对应到服务端提供实际存储空间的设备,需要起一个管理名称

• target,磁盘组(木质箱子)
– 是客户端的访问目标,作为一个框架,由多个lun组成

• lun,逻辑单元(将大冰箱放入木质箱子)
– 每一个lun需要关联到某一个后端存储设备,在客户端
会视为一块虚拟硬盘

使用targetcli建立配置
• ISCSI Qualified Name 名称规范
– iqn.yyyy-mm.倒序域名:自定义标识
–  用来识别 target 磁盘组, 也用来识别客户机身份


                 冰箱------>纸质包装------->木质箱子

一  虚拟机Server0:划分分区
1.利用fisk /dev/vdb命令,划分一个5G的主分区

[root@server0 ~]# lsblk
[root@server0 ~]# ls /dev/vdb1
/dev/vdb1
[root@server0 ~]# 


虚拟机Server0:服务端
一 防火墙设置为trusted

二 安装软件包targetcli(服务端软件),进行配置
[root@server0 ~]# yum  -y  install  targetcli
[root@server0 ~]# targetcli
 /> ls

   1.创建后端存储 backstore,后端存储(冰箱进行纸质包装)
  /> backstores/block create name=nsd  dev=/dev/vdb1
           后端存储/块设备          创建       名字              实际设备
  /> ls

   2.创建 target,磁盘组 (木质箱子)
  /> iscsi/ create  iqn.2018-10.example.com:server0
           
  /> ls
  /> exit   #默认退出保存

   3.进行关联, lun 逻辑单元
  [root@server0 ~]# targetcli 
  /> ls

  /> iscsi/iqn.2018-10.example.com:server0/tpg1/  
   luns     create   /backstores/block/nsd 

  /> ls

   4.访问控制, 设置客户端访问服务端时,声称的名字(符合iqn格式)
 /> iscsi/iqn.2018-10.example.com:server0/tpg1/acls  
   create  iqn.2018-10.example.com:desktop0

 /> ls

   5.开放本机的IP地址与端口
  /> iscsi/iqn.2018-10.example.com:server0/tpg1/  
  portals create 172.25.0.11

  /> ls

  /> exit

三 重起服务端target服务
[root@server0 ~]# systemctl restart target
[root@server0 ~]# systemctl enable target

客户端:虚拟机desktop0

1.防火墙设置默认区域为trusted
2.安装软件包(客户端软件包)
   Yum补全包名:  
           1. 本机没有安装该包   2.必须有Yum缓存

 [root@desktop0 ~]# rpm -q iscsi-initiator-utils
 iscsi-initiator-utils-6.2.0.873-21.el7.x86_64

3.指定客户端声称的名字    
 # vim /etc/iscsi/initiatorname.iscsi 
 InitiatorName=iqn.2018-10.example.com:desktop0
 
  命令模式下    u  可以进行撤销

4.重起iscsid服务,刷新客户端声称的名字
 [root@desktop0 ~]# systemctl restart iscsid
  Warning: Unit file of iscsid.service changed on  
  disk, 'systemctl daemon-reload' recommended.
 [root@desktop0 ~]# systemctl daemon-reload
 [root@desktop0 ~]# systemctl restart iscsid

5.发现服务端共享存储
 书写发现的命令,  参考# man iscsiadm  搜索全文 /example

   Ctrl    - ：减小字体
   Ctrl   Shift   + ：变大字体

 # iscsiadm --mode discoverydb --type sendtargets --
   portal 172.25.0.11  --discover

6.加载共享存储
	# lsblk 
	# systemctl restart iscsi  #重起服务加载共享存储
	# systemctl enable iscsi
	# lsblk 
	# ls /dev/sda

##################################################
总结:
服务端:
  1.防火墙默认区域设置为trusted
  2.安装软件包targetcli
      A:建立后端存储
      B:建立target磁盘组
      C:关联lun
      D:设置acl访问控制,客户端声称的名字
      E:开启本机的IP地址及端口
  3.重起target服务

客户端:
  1.防火墙默认区域设置为trusted
  2.安装软件包iscsi-initiator-utils
  3.修改文件/etc/iscsi/initiatorname.iscsi客户端声称的名字
  4.重起iscsid服务刷新客户端iqn标识
  5.书写客户端发现命令,参照man iscsiadm
  6.重起iscsi服务,加载共享存储  最终利用lsblk查看新磁盘

##################################################
数据库管理

数据库:存放数据的仓库

– 社区开源版 MariaDB  默认端口:3306     

• RHEL7 中的 MariaDB 相关包
– mariadb-server:提供服务端有关的系统程序
– mariadb:提供客户端及管理工具

 mariadb数据库中,会有很多的库,在每一个库中会有很多的表格


一  安装数据库
[root@server0 ~]# yum -y install mariadb-server

[root@server0 ~]# systemctl restart mariadb
[root@server0 ~]# systemctl enable mariadb

二  数据库基本操作
[root@server0 ~]# mysql
	> show databases;           #显示所有库
	> create database nsd1809;  #创建nsd1809库
	> show databases;           #显示所有库

	> drop database nsd1809;    #删除nsd1809库
	> show databases;           #显示所有库
 
	> create database nsd;      #创建nsd库
	> show databases;           #显示所有库
	> exit                      #结束退出mariadb

###############################################
三  为数据库管理员设置密码

  数据库管理员 root: MariaDB数据库中mysql库--->user表 
  系统管理员 root: 账户信息存放在/etc/passwd

Linux系统命令行
• 为数据库账号修改密码
– mysqladmin [-u用户名] [-p[旧密码]] password '新密码'

[root@server0 ~]# mysqladmin -u root password '123'

[root@server0 ~]# mysql -u root  -p  #交互式进入
Enter password: 

[root@server0 ~]# mysql -u root -p123  #非交互式进入



• 禁止监听,只服务于本机,MariaDB主配文件为/etc/my.cnf

##############################################

• 导入/恢复到数据库
– mysql [-u用户名] [-p[密码]] 数据库名 < 备份文件.sql

# wget http://classroom.example.com/pub/materials/users.sql
# ls 
# mysql -u root -p123 nsd  <  users.sql   #导入数据
# mysql -u root -p123                     #进入数据库
 MariaDB [(none)]> use nsd;       #进入nsd库
 MariaDB [nsd]> show tables;      #显示所有表格
 +---------------+
 | Tables_in_nsd |       
 +---------------+
 | base          |
 | location      |
 +---------------+
 2 rows in set (0.00 sec)

#################################################
表格操作:  
  insert(增)  delete(删)  update(改)  select(查)

  表字段   表记录

查询表格内容
   select  表字段   from  表名;
   select  表字段   from  库名.表名;

[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> use nsd;
MariaDB [nsd]> show tables;
MariaDB [nsd]> select * from base;
MariaDB [nsd]> select name from base;
MariaDB [nsd]> select name,password from base;

MariaDB [nsd]> select * from location;
MariaDB [nsd]> select id from location;

MariaDB [(none)]> select * from nsd.base;

查看表结构的命令: desc
MariaDB [(none)]> use nsd;
MariaDB [nsd]> desc base;

MariaDB [nsd]> use mysql;
MariaDB [mysql]> desc user;
MariaDB [mysql]> select user,host,password from user;
                                  
##################################################
数据库的授权
– 除了root用户,此nsd数据库能被用户dc查询,此用户的密码为123

• MariaDB [(none)]> 交互指令
– GRANT 权限列表 ON 数据库名.表名 TO 用户名@
客户机地址 IDENTIFIED BY '密码';

[root@server0 ~]# mysql -u root -p123

> grant select on nsd.* to dc@localhost identified by '123';

当dc从locahost登陆输入密码123,将会获得nsd库所有表的查询权限

MariaDB [nsd]> use mysql;
MariaDB [mysql]> desc user;
MariaDB [mysql]> select user,host,password from user;

验证:
[root@server0 ~]# mysql -u dc -p123

################################################






环境准备:
虚拟机Server0:
# firewall-cmd  --set-default-zone=trusted

虚拟机Desktop0:
# firewall-cmd  --set-default-zone=trusted

################################################

HTTP服务基础    

搭建基本Web服务
虚拟机server0
1.安装软件包httpd
2.书写一个页面文件
 echo '<h1>NSD1809 Web' > /var/www/html/index.html
3.重起服务
# systemctl restart httpd
# systemctl enable httpd

4.虚拟机desktop0 访问测试: firefox  172.25.0.11
ssh -X root@192.168.10.1


Web通信基本概念
• 基于 B/S (Browser/Server)架构的网页服务
– 服务端提供网页
– 浏览器下载并显示网页

• Hyper Text Markup Language(HTML),超文本标记语言
• Hyper Text Transfer Protocol(HTTP),超文本传输协议

• 软件包:httpd
• 系统服务:httpd
• 提供的默认配置
– Listen:监听地址:端口(80)
– ServerName:本站点注册的DNS名称(空缺)
– DocumentRoot:网页根目录(/var/www/html)
– DirectoryIndex:起始页/首页文件名(index.html)


############################################
– ServerName:本站点注册的DNS名称(空缺)

    需要DNS服务器域名解析前提

        DNS服务器:classroom.example.com

               域名:server0.example.com
               域名:www0.example.com
               域名:webapp0.example.com

[root@desktop0 ~]# nslookup server0.example.com
[root@desktop0 ~]# nslookup www0.example.com
[root@desktop0 ~]# nslookup webapp0.example.com

################################################
主配置文件:/etc/httpd/conf/httpd.conf
– ServerName:本站点注册的DNS名称(空缺) 

虚拟机Server0:
1.修改主配置文件:/etc/httpd/conf/httpd.conf
  vim命令模式下  /ServerName  全文查找ServerName

   95 ServerName server0.example.com:80

2.重起httpd服务
 #systemctl restart httpd

3.访问测试
[root@desktop0 ~]# firefox server0.example.com

################################################

– DocumentRoot:网页文件根目录
                            (存放网页文件路径默认是/var/www/html)

虚拟机Server0
# mkdir /var/www/myweb
# echo '<h1>wo shi MyWeb' > /var/www/myweb/index.html
# cat /var/www/myweb/index.html

[root@server0 ~]# vim /etc/httpd/conf/httpd.conf 
DocumentRoot "/var/www/myweb"  #指定网页文件存放路径

[root@server0 ~]# systemctl restart httpd

虚拟机desktop0
[root@desktop0 ~]#  firefox server0.example.com

################################################
当 客户端  172.25.0.11:80  服务端 httpd--->DocmentRoot

DocumentRoot "/var/www/myweb" 

网络路径:firefox  server0.example.com
实际路径:/var/www/myweb

网络路径:firefox  server0.example.com/abc/private
实际路径:/var/www/myweb/abc/private

DocumentRoot "/var/www/myweb" 

firefox server0.example.com/var/www/myweb/abc/private

实际路径:/var/www/myweb/var/www/myweb/abc/private


#################################################

# mkdir /var/www/myweb/abc
# echo '<h1>wo shi abc' > /var/www/myweb/abc/index.html


# firefox server0.example.com/abc


################################################
虚拟Web主机
– 由同一台服务器提供多个不同的Web站点

• 区分方式
– 基于域名的虚拟主机
– 基于端口的虚拟主机
– 基于IP地址的虚拟主机


################################################
– 基于域名的虚拟主机

 <VirtualHost  IP地址:端口>
   ServerName  此站点的DNS名称
   DocumentRoot  此站点的网页根目录
 </VirtualHost>

• 配置文件路径
– /etc/httpd/conf/httpd.conf  主配置文件
– /etc/httpd/conf.d/*.conf    调用配置文件


虚拟机server0
# mkdir /var/www/qq /var/www/baidu
# echo '<h1>企鹅'  > /var/www/qq/index.html
# echo '<h1>百度'  > /var/www/baidu/index.html

# vim /etc/httpd/conf.d/nsd01.conf
 <VirtualHost  *:80>         #所有IP地址开放80端口
   ServerName    www0.example.com  #指定网站名称
   DocumentRoot  /var/www/qq       #指定网页文件存放路径
 </VirtualHost>

 <VirtualHost  *:80>
   ServerName    webapp0.example.com
   DocumentRoot  /var/www/baidu
 </VirtualHost>

 <VirtualHost *:80>
  ServerName   server0.example.com
  DocumentRoot   /var/www/myweb
 </VirtualHost>

# systemctl  restart httpd



一旦使用虚拟web主机功能,所有的网站都必须用虚拟web主机实现

#################################################
网页内容访问


客户机地址限制

• 使用 <Directory> 配置区段
– 每个文件夹自动继承其父目录的访问权限
– 除非针对子目录有明确设置

               /opt     拒绝所有访问
               /opt/index.html

               /opt/test/index.html

    <Directory 目录的绝对路径>
	.. ..
	Require all denied|granted
	Require ip IP或网段地址 .. ..
	</Directory>

   <Directory  /var/www/html>
	Require all denied|granted #拒绝所有 | 允许所有
	Require ip 172.25.0.10   #仅允许172.25.0.10进行访问
   </Directory>




案例3:配置网页内容访问
在 Web 网站 http://server0.example.com 的
DocumentRoot 目录下创建一个名为 private 的子目录,要求如下:

1.查看 server0.example.com 的DocumentRoot 目录
# cat /etc/httpd/conf.d/nsd01.conf 

2.创建目录,写入页面文件
# mkdir /var/www/myweb/private
# echo '<h1> wo shi private' > /var/www/myweb/private/index.html

# cat /var/www/myweb/private/index.html

3.在虚拟机server与虚拟机desktop上 访问测试
   firefox  server0.example.com/private

4.从 server0 上,任何人都可以浏览 private的内容,
但是从其他系统不能访问这个目录的内容  
[root@server0 ~]# vim /etc/httpd/conf/httpd.conf 
[root@server0 ~]# vim /etc/httpd/conf.d/nsd02.conf
<Directory "/var/www/myweb/private">
    Require ip 172.25.0.11
</Directory>
[root@server0 ~]# systemctl restart httpd

5.在虚拟机desktop0进行验证:
[root@desktop0 ~]#firefox server0.example.com/private
Forbidden
You don't have permission to access /private on this server.

################################################
案例4:使用自定Web根目录
调整 Web 站点 http://server0.example.com 的网页
目录,要求如下:
1)新建目录 /webroot,作为此站点新的网页目录
  # mkdir /webroot
  # echo '<h1>wo shi webroot' > /webroot/index.html
2)修改虚拟Web主机配置文件,指定新的网页目录
 # vim /etc/httpd/conf.d/nsd01.conf 
   <VirtualHost *:80>
    ServerName  server0.example.com
    DocumentRoot  /webroot
   </VirtualHost>
3)修改Web访问控制配置文件,允许所有人访问
  # vim /etc/httpd/conf.d/nsd02.conf 
   <Directory    "/webroot">
     Require  all  granted      
   </Directory>
4)重起服务
[root@server0 ~]# systemctl restart httpd

5) 修改SELinux策略,安全上下文值(标签值)  
[root@server0 ~]# ls  -Zd  /var/www/
[root@server0 ~]# ls  -Zd  /webroot/

• 方式1:参照标准目录,重设新目录的属性
– chcon [-R] --reference=模板目录   新目录

# chcon  -R --reference=/var/www/  /webroot

[root@server0 ~]# ls  -Zd  /var/www/
[root@server0 ~]# ls  -Zd  /webroot/ 

###########################################
  客户端访问服务端:
        1.防火墙
        2.服务本身的访问控制
        3.本地目录的权限
        4.安全增强版 SELinux策略
#############################################
部署动态网站

   LAMP (Linux Apache MySQL/MariaDB php/python) 

   LNMP (Linux Nginx MySQL/MariaDB php/python) 


静态网站的运行
• 服务端的原始网页 = 浏览器访问到的网页
– 由Web服务软件处理所有请求
– 文本(txt/html)、图片(jpg/png)等静态资源


动态网站的运行
• 服务端的原始网页 ≠ 浏览器访问到的网页
– 由Web服务软件接受请求,动态程序转后端模块处理
– PHP网页、Python网页、JSP网页......

虚拟机Server0:
1.以webapp0.example.com部署Python页面
# cat /etc/httpd/conf.d/nsd01.conf #查看DocmentRoot
# cd /var/www/baidu/
# wget http://classroom.example.com/pub/materials/webinfo.wsgi

# cat webinfo.wsgi

2.用户方便的访问(页面跳转/页面的别名)

  Alias   网络路径    本机实际路径
[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf
  <VirtualHost *:80>
   ServerName  webapp0.example.com
   DocumentRoot  /var/www/baidu
   Alias    /     /var/www/baidu/webinfo.wsgi
      当客户端直接访问网页文件根目录时,将webinfo.wsgi呈现
  </VirtualHost>
[root@server0 /]# systemctl restart httpd

3.安装mod_wsgi软件包,翻译Python页面代码
[root@server0 /]# yum -y install mod_wsgi

4.修改配置文件,进行翻译Python页面代码 

[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf
  <VirtualHost *:80>
   ServerName  webapp0.example.com
   DocumentRoot  /var/www/baidu
   WsgiScriptAlias  /  /var/www/baidu/webinfo.wsgi
      当客户端直接访问网页文件根目录时,将webinfo.wsgi呈现
  </VirtualHost>
[root@server0 /]# systemctl restart httpd

  Unix时间戳: 从1970-1-1 0:0:0到现在时间,所经历的秒数

5.此虚拟主机侦听在端口8909
Listen 8909           #配置httpd程序监听8909端口
<VirtualHost *:8909>  #虚拟web主机监听8909
  ServerName webapp0.example.com
  DocumentRoot /var/www/baidu
  WsgiScriptAlias /  /var/www/baidu/webinfo.wsgi
</VirtualHost>

6. SELinux非默认端口的开放
# semanage port -l | grep http
# semanage port -a -t http_port_t     -p tcp 8909 
   -a:添加    -t:类型     -p:协议
# systemctl restart httpd

7.验证:
 http://webapp0.example.com:8909

##############################################
默认端口访问优先级最高,默认端口不匹配,显示第一个虚拟Web主机内容

###############################################




环境准备:
虚拟机Server0:
# firewall-cmd  --set-default-zone=trusted

虚拟机Desktop0:
# firewall-cmd  --set-default-zone=trusted

################################################
安全的Web的构建   

• Public Key Infrastructure,公钥基础设施
– 公钥:主要用来加密数据
– 私钥:主要用来解密数据(与相应的公钥匹配)
– 数字证书:证明拥有者的合法性/权威性(单位名称、
有效期、公钥、颁发机构及签名、......)
– Certificate Authority,数字证书授权中心:负责证书
的申请/审核/颁发/鉴定/撤销等管理工作


1.部署网站证书(营业执照)
# cd  /etc/pki/tls/certs/   #默认存放网站证书路径
# wget http://classroom.example.com/pub/tls/certs/server0.crt

# ls 

2.部署根证书(公安局信息)
# cd  /etc/pki/tls/certs/
# wget http://classroom.example.com/pub/example-ca.crt

# ls 

3.部署私钥匙(解密)
# cd /etc/pki/tls/private/
# wget http://classroom.example.com/pub/tls/private/server0.key

# ls 

4.安装软件包  
[root@server0 /]# yum -y install httpd
[root@server0 /]# yum -y install mod_ssl(支持加密通信)
[root@server0 /]# ls /etc/httpd/conf.d/
  ssl.conf 

5.修改配置文件/etc/httpd/conf.d/ssl.conf 
# echo '<h1>NSD1809 Web' > /var/www/html/index.html
 
[root@server0 /]# vim /etc/httpd/conf.d/ssl.conf
 在末行模式下   :set  nu  显示行号

 59 DocumentRoot "/var/www/html"
 60 ServerName www0.example.com:443

指定网站证书   11:10---->11:20
100 SSLCertificateFile /etc/pki/tls/certs/server0.crt

指定私钥
107 SSLCertificateKeyFile /etc/pki/tls/private/server0.key

指定根证书
122 SSLCACertificateFile /etc/pki/tls/certs/example-ca.crt
6.重起httpd服务
[root@server0 /]# systemctl restart httpd
7.验证:
[root@desktop0 ~]# firefox https://www0.example.com
     点击  了解安全的风险  ---->添加例外----->确认安全例外

#################################################
基础邮件服务

• 电子邮件服务器的基本功能
– 为用户提供电子邮箱存储空间(用户名@邮件域名)
– 处理用户发出的邮件 —— 传递给收件服务器
– 处理用户收到的邮件 —— 投递到邮箱

    SMTP:用户发出的邮件的协议  默认端口  25
    pop3:用户收到的邮件的协议  默认端口 110

  DNS服务器:classroom.example.com

    zhangsan@server0.example.com

1.安装postfix软件包,搭建为邮件服务器
[root@server0 /]# rpm -q postfix
postfix-2.10.1-6.el7.x86_64
[root@server0 /]# 

2.修改配置文件
[root@server0 /]# vim /etc/postfix/main.cf 
  末行模式  :set  nu  开启行号
 99 myorigin = server0.example.com  #默认补全的域名后缀
116 inet_interfaces = all   #允许本机所有接口使用邮件服务
164 mydestination = server0.example.com
                                                      #判断为本域邮件
3.重起服务
[root@server0 /]# systemctl restart postfix

邮件测试:
   1.建立邮箱的帐号
  [root@server0 /]# useradd yg
  [root@server0 /]# useradd xln

   2.发信操作与收信操作
  • mail 发信操作
   – mail -s '邮件标题'   -r 发件人   收件人[@收件域]...
  • mail 收信操作
   – mail [-u 用户名]

[root@server0 /]# mail -s 'test01' -r yg  xln
haha xixi jhehe lele         
.
EOT

非交互式发邮件
# echo nsd1809 | mail -s 'test02' -r yg  xln

收取xln的邮件
[root@server0 /]# mail -u xln
>N  1 yg@server0.example.c  Fri Oct 19 14:22  20/626   
& 1          # 输入编号1

& q     #退出
################################################
准备交换分区

•使用fdisk操作适合  MBR分区模式,最大容量2.2TB
            1GB=1000MB   (厂商)
            1GiB=1024MiB   (计算机)

•使用parted操作适合 GPT分区模式,支持128主分区,最大容量18EB
             1EB=1000PB
             1PB=1000TB
             1TB=1000GB      

[root@server0 ~]# parted   /dev/vdb
(parted) mktable gpt        #指定分区模式为GPT
(parted) print              #输出分区信息
(parted) mkpart             #划分新的分区
分区名称？  []? nsd             #分区的名称
文件系统类型？  [ext2]?  ext4     #分区的文件系统,不起作用
起始点？ 0                                        
结束点？ 2G    
忽略/Ignore/放弃/Cancel? Ignore  #忽略 
(parted) unit GB               #使用GB作为显示单位
(parted) print                  
(parted) mkpart 
分区名称？  []? nsd  
文件系统类型？  [ext2]? ext4            
起始点？ 2G          
结束点？ 4G 

[root@server0 ~]# lsblk



什么是交换空间
• 相当于虚拟内存
– 当物理内存不够用时,使用磁盘空间来模拟内存
– 在一定程度上缓解内存不足的问题
– 交换分区:以空闲分区充当的交换空间


[root@server0 ~]# ls /dev/vdb[1-2]
/dev/vdb1  /dev/vdb2

1.格式化交换文件系统
[root@server0 ~]# mkswap /dev/vdb1  
[root@server0 ~]# blkid /dev/vdb1
[root@server0 ~]# mkswap /dev/vdb2
[root@server0 ~]# blkid /dev/vdb2
2.启用交换分区
[root@server0 ~]# swapon /dev/vdb1
[root@server0 ~]# swapon  /dev/vdb2
[root@server0 ~]# swapon -s       #查看交换分区组成信息
3.停用交换分区
[root@server0 ~]# swapoff /dev/vdb2
[root@server0 ~]# swapon -s
[root@server0 ~]# swapoff /dev/vdb1
[root@server0 ~]# swapon -s
4.实现开机自动启用交换分区     
[root@server0 ~]# vim /etc/fstab 
/dev/vdb1  swap swap defaults 0 0
/dev/vdb2  swap swap defaults 0 0

[root@server0 ~]# swapon -a   #专用于检测swap分区
[root@server0 ~]# swapon -s

[root@server0 ~]# swapoff /dev/vdb1
[root@server0 ~]# swapoff /dev/vdb2
[root@server0 ~]# swapon -s
[root@server0 ~]# swapon -a
[root@server0 ~]# swapon -s

###############################################
MariaDB数据库
1.搭建数据库
[root@server0 ~]# yum -y install mariadb-server
2.重起mariadb
[root@server0 ~]# systemctl restart mariadb
3.设置数据库管理员的密码
[root@server0 ~]# mysqladmin -u root password '123'
3.建立nsd库
[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> create database nsd;  #创建nsd库
MariaDB [(none)]> show databases;  #查看所有库

4.导入数据
[root@server0 ~]# wget http://classroom.example.com/pub/materials/users.sql

[root@server0 ~]# mysql -u root -p123 nsd < users.sql
[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> use nsd;   #切换到库nsd
MariaDB [nsd]> show tables;  #查看所有的表格
案例5:使用数据库查询
1. 在系统 server0 上使用数据库 nsd,并使用相
应的 SQL 查询以回答下列问题:
1)密码是 solicitous 的人的名字?
> use nsd;
> select * from base;
> select * from base where password='solicitous';
> select * from base where name='tom';
> select * from base where password='456';

2)有多少人的 姓名是 Barbara 同时居住在 Sunnyvale
> select  *  from   base,location   
  where base.name='Barbara'   and                    
     location.city='Sunnyvale'  and            
     base.id=location.id;

> select   count(*)  from   base,location   
  where base.name='Barbara'   and                    
    location.city='Sunnyvale'    and            
    base.id=location.id;

> insert  base  values('6','Barbara','789');
> insert  location  values('6','Sunnyvale');
> select * from base;
> select * from location;


2. 禁止空密码root用户访问 mariadb 数据库
> use mysql;
> desc user;    #查看表结构
> select  user,host,password   from user;

> select  user,host,password   from user  where password='';

> delete  from user   where   password='';
> select  user,host,password   from  user;

> flush  privileges;   #刷新user表记录

测试登陆失败,利用域名方式登陆
# mysql -u root -h server0.example.com
################################################





















  










































